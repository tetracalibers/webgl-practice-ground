---
title: ビット演算を駆使して、バッファを使わずにキャンバスを覆う三角形を描く話
---

# Render full screen triangle in WebGL 2

GLSL（ESSL）の練習では、キャンバス一面になんだかんだ描きたい。

つまり、フラグメントシェーダで塗りつぶす対象の図形をキャンバス全体に広げたい。

しかし、そのためだけにVBOをつくる等、WebGLコードが長くなるのはめんどくさいので、最初から頂点シェーダでキャンバスを覆う図形の頂点を計算させる。

WebGL側ではほぼ`gl.drawArrays(gl.TRIANGLE_FAN, 0, 3)`を呼び出すだけ。

…というようなことを実現するスニペットがgistに転がっていた。

https://gist.github.com/strangerintheq/27b8fc4e53432d8b9284364713ce8608

頂点シェーダだけ引用。（`gl_VertexID`やビット演算を使っている時点でWebGL1では動かない）

```glsl:頂点シェーダ
#version 300 es

void main() {
  float x = float((gl_VertexID & 1) << 2);
  float y = float((gl_VertexID & 2) << 1);
  gl_Position = vec4(x - 1.0, y - 1.0, 0, 1);
}
```

このコードにより、最終的に(-1, -1), (1, -1), (-1, 1), (1, 1)の4点を結ぶ矩形が描かれることになる。（その矩形上に何を描くかは、フラグメントシェーダ次第。）

ビット演算の思考練習も兼ねて、この謎めいた頂点シェーダがどういう原理でその4点を導くのか、ロジックを追ってみる。

# 原理

## gl_VertexID

`gl_VertexID`は、現在の実行対象となっている頂点のインデックス。

- [gl_VertexID と gl_InstanceID](https://wgld.org/d/webgl2/w008.html)

`gl.drawElements`でインデックスを指定している場合は、その指定された番号。

`gl.drawArrays`でインデックスなしで描画している場合は、これまで処理された頂点の数、つまり、処理された順に勝手に振られた連番。

- [Advanced GLSL](https://learnopengl.com/Advanced-OpenGL/Advanced-GLSL)

今回の場合は、取りうる`gl_VertexID`の値は0, 1, 2, 3。

## AND演算

同じ桁を見比べたときに、両方が1なら1、そうでなければ0。

```glsl
// gl_VertexID = 0 の場合
(gl_VertexID & 1) = 0000 & 0001 = 0000
(gl_VertexID & 2) = 0000 & 0010 = 0000

// gl_VertexID = 1 の場合
(gl_VertexID & 1) = 0001 & 0001 = 0001
(gl_VertexID & 2) = 0001 & 0010 = 0000

// gl_VertexID = 2 の場合
(gl_VertexID & 1) = 0010 & 0001 = 0000
(gl_VertexID & 2) = 0010 & 0010 = 0010

// gl_VertexID = 3 の場合
(gl_VertexID & 1) = 0011 & 0001 = 0001
(gl_VertexID & 2) = 0011 & 0010 = 0010
```

## 左シフト

```glsl
// gl_VertexID = 0 の場合
(gl_VertexID & 1) << 2 = 0000 << 2 = 0000
(gl_VertexID & 2) << 1 = 0000 << 1 = 0000

// gl_VertexID = 1 の場合
(gl_VertexID & 1) << 2 = 0001 << 2 = 0100
(gl_VertexID & 2) << 1 = 0000 << 1 = 0000

// gl_VertexID = 2 の場合
(gl_VertexID & 1) << 2 = 0000 << 2 = 0000
(gl_VertexID & 2) << 1 = 0010 << 1 = 0100

// gl_VertexID = 3 の場合
(gl_VertexID & 1) << 2 = 0001 << 2 = 0100
(gl_VertexID & 2) << 1 = 0010 << 1 = 0100
```

## float

### ビット列フル表示

ここまで、簡略化のために上位4ビットだけを表示してきた。

float型に変換した結果、どんな値になるかを探るために、32bitフル表示すると、0100はこうなる。

```
01000000000000000000000000000000
```

[浮動小数点数内部表現シミュレーター](https://tools.m-bsys.com/calculators/ieee754.php)で可視化すると、こんな感じ。

![](/webgl-practice-ground/articles/img/float-2.png)

### 浮動小数点数そもそも論

浮動小数点数は、例えば $-0.00025$ を $-0.25 \times 10^{-3}$ のように、指数表記で数値を表現する方法。

このとき、$25$ を仮数部、$10$ を基数、$-3$ を指数部と呼ぶ。

仮数部の最上位桁は0以外でなければならない。つまり、$-0.025 \times 10^{-2}$ とかはダメ。

コンピュータで扱う数字は2進数なので、以降、基数は$2$ とする前提で話を進める。

このような浮動小数点数をビット列でどう表すかというと、まあ形式はいろいろあるが、IEEE754形式のfloat型は、左から

- 仮数部の符号：1ビット（正なら0、負なら1）
- 指数部：8ビット（2進数表記）
- 仮数部：23ビット（2進数表記）

という内訳の32ビットで表す。

#### 指数部

指数部は8ビットあるので、00000000（10進数の0）から11111111（10進数の255）までを表すことができる。
が、問題は、指数は負の数である場合もあるということだ。

そこで、0 ~ 255のちょうど真ん中である127という数値を原点とし、

- 指数部が00000000の場合、実際の指数は-127
- 指数部が11111111の場合、実際の指数は128

という対応づけをすることで、指数が負の数の場合もカバーできるようにする。

つまり、**実際の指数 = 指数部ビット列を10進数表記した値 - 127**だ。

#### 仮数部

2進数では、0と1の組み合わせであらゆる数値を表現するため、先ほど書いた「仮数部の最上位桁は0以外でなければならない」という規則に則ると、仮数部の最上位桁は必ず1になる。

このわかりきっている1のために1ビットを使うのは勿体無いということで、この部分は仮数部ビット列にはあえて書かない。

このような都合から、IEEE754形式では、$0.M \times 2^N$ という形式ではなく、$1.M \times 2^N$という形式で表すことにしている。

そして、この $M$ の部分を2進数表記したものが、仮数部のビット列として格納される。

### 0100の正体

前提はこれで十分。では、float型の01000000000000000000000000000000は何の数値を表すのか。

- 符号：0
- 指数部：10000000
- 仮数部：00000000000000000000000

まず符号が0なので、正の数である。

指数部は10000000だが、これは10進数表記すると128。127を引いて、1が実際の指数だとわかる。

仮数部は紛れもなく0だが、これは $1.M$ の小数部分 $M$ に過ぎないので実際の仮数は1.0だ。

つまり、$1.0 \times 2^1 = 2.0$ となる。

## [-1, 1]範囲に収める

ビット列0100が表す数値は2なので、各場合のx, yの数値は、次のように[0, 2]範囲の整数の組み合わせとなる。

```glsl
// gl_VertexID = 0 の場合
x = float((gl_VertexID & 1) << 2) = 0 // ビット列0000
y = float((gl_VertexID & 2) << 1) = 0 // ビット列0000

// gl_VertexID = 1 の場合
x = float((gl_VertexID & 1) << 2) = 2 // ビット列0100
y = float((gl_VertexID & 2) << 1) = 0 // ビット列0000

// gl_VertexID = 2 の場合
x = float((gl_VertexID & 1) << 2) = 0 // ビット列0000
y = float((gl_VertexID & 2) << 1) = 2 // ビット列0100

// gl_VertexID = 3 の場合
x = float((gl_VertexID & 1) << 2) = 2 // ビット列0100
y = float((gl_VertexID & 2) << 1) = 2 // ビット列0100
```

これらx, yから1.0を引くことで、`gl_VertexID`の値に応じて、それぞれ(-1, -1), (1, -1), (-1, 1), (1, 1)という座標が得られることになる。

```glsl
gl_Position = vec4(x - 1.0, y - 1.0, 0, 1);
```

# 参考

- [床井研究室 - 矩形の描き方](https://marina.sys.wakayama-u.ac.jp/~tokoi/?date=20160831)
- [10進数/16進数/2進数の変換テーブル](http://www.rtpro.yamaha.co.jp/RT/docs/misc/number-table.html)
